#pragma once
#include <vector>
#include <string>
#include <unordered_map>
#include <fstream>
#include <sstream>

struct Mesh {
    std::vector<float> vertices; // x,y,z, u,v, nx,ny,nz
    std::vector<unsigned int> indices;
};

struct Material {
    float kd[3] = {1,1,1};
    std::string texPath;
};

inline Mesh loadObjMtl(const char* objPath, std::unordered_map<std::string, Material>& materials, const char* baseDir = "") {
    Mesh mesh;
    std::vector<Material> usedMaterials;
    std::vector<float> pos, uv, norm;
    std::vector<std::tuple<int,int,int>> faceData;
    std::vector<int> faceMat;

    std::ifstream in(objPath);
    std::string line, currentMat;
    while (std::getline(in,line)) {
        std::istringstream iss(line);
        std::string type; iss >> type;
        if (type=="mtllib") {
            std::string mtl; iss >> mtl;
            std::ifstream m(in, std::string(baseDir)+mtl);
            std::string l;
            Material mat;
            std::string name;
            while (std::getline(m,l)) {
                std::istringstream im(l);
                std::string t; im >> t;
                if (t=="newmtl") { if (!currentMat.empty()) materials[currentMat] = mat;
                    im >> name; currentMat = name; mat = Material();
                } else if (t=="Kd") { im >> mat.kd[0] >> mat.kd[1] >> mat.kd[2]; }
                else if (t=="map_Kd") { im >> mat.texPath; }
            }
            if (!currentMat.empty()) materials[currentMat] = mat;
        } else if (type=="usemtl") {
            iss >> currentMat;
        } else if (type=="v") {
            float x,y,z; iss>>x>>y>>z;
            pos.insert(pos.end(),{x,y,z});
        } else if (type=="vt") {
            float u,v; iss>>u>>v;
            uv.insert(uv.end(),{u,v});
        } else if (type=="vn") {
            float nx,ny,nz; iss>>nx>>ny>>nz;
            norm.insert(norm.end(),{nx,ny,nz});
        } else if (type=="f") {
            std::string a,b,c;
            iss>>a>>b>>c;
            auto parseIdx=[&](const std::string& s){
                int v=-1, t=-1, n=-1;
                sscanf(s.c_str(), "%d/%d/%d",&v,&t,&n);
                return std::make_tuple(v-1, t-1, n-1);
            };
            faceData.push_back(parseIdx(a));
            faceData.push_back(parseIdx(b));
            faceData.push_back(parseIdx(c));
            faceMat.push_back(currentMat.empty()? -1 : std::distance(materials.begin(), materials.find(currentMat)));
        }
    }

    // build interleaved buffer
    std::unordered_map<std::string,int> matIdMap;
    int idx=0;
    std::map<std::tuple<int,int,int>, int> unique;
    for (size_t i=0; i<faceData.size(); ++i) {
        auto t = faceData[i];
        if (unique.count(t)==0) {
            unique[t] = idx++;
            auto [vi, ti, ni] = t;
            mesh.vertices.push_back(pos[vi*3+0]);
            mesh.vertices.push_back(pos[vi*3+1]);
            mesh.vertices.push_back(pos[vi*3+2]);
            if (ti>=0) {
                mesh.vertices.push_back(uv[ti*2+0]);
                mesh.vertices.push_back(uv[ti*2+1]);
            } else mesh.vertices.insert(mesh.vertices.end(),{0,0});
            if (ni>=0) {
                mesh.vertices.push_back(norm[ni*3+0]);
                mesh.vertices.push_back(norm[ni*3+1]);
                mesh.vertices.push_back(norm[ni*3+2]);
            } else mesh.vertices.insert(mesh.vertices.end(),{0,0,1});
        }
        mesh.indices.push_back(unique[t]);
    }

    return mesh;
}
#include <SDL.h>
#include <GLES2/gl2.h>
#include <emscripten.h>
#include "loadObjMtl.h"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

SDL_Window* window;
SDL_GLContext glContext;
Mesh mesh;
GLuint program, vbo, ibo, tex = 0;
std::unordered_map<std::string, Material> materials;

float rotX=0, rotY=0;
bool mouseDown=false;
int lastX, lastY;

const char* vs = R"(
attribute vec3 aPos;
attribute vec2 aUV;
varying vec2 vUV;
uniform float rotX, rotY;
void main(){
    float cx = cos(rotX), sx=sin(rotX);
    float cy = cos(rotY), sy=sin(rotY);
    mat3 Rx = mat3(1,0,0, 0,cx,-sx, 0,sx,cx);
    mat3 Ry = mat3(cy,0,sy, 0,1,0, -sy,0,cy);
    vec3 p = Ry * Rx * aPos;
    gl_Position = vec4(p,1.0);
    vUV = aUV;
}
)";
const char* fs = R"(
precision mediump float;
varying vec2 vUV;
uniform sampler2D tex;
void main(){
    gl_FragColor = texture2D(tex, vUV);
}
)";

bool init(){
    SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
    window = SDL_CreateWindow("Obj+Mtl Loader", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800,600, SDL_WINDOW_OPENGL);
    glContext = SDL_GL_CreateContext(window);
    glViewport(0,0,800,600);

    mesh = loadObjMtl("assets/cube.obj", materials, "assets/");
    printf("Verts: %zu, idx: %zu\n", mesh.vertices.size()/8, mesh.indices.size());

    GLuint vsId = compileShader(GL_VERTEX_SHADER, vs);
    GLuint fsId = compileShader(GL_FRAGMENT_SHADER, fs);
    program = glCreateProgram();
    glAttachShader(program, vsId); glAttachShader(program, fsId);
    glBindAttribLocation(program, 0, "aPos");
    glBindAttribLocation(program, 1, "aUV");
    glLinkProgram(program);

    glGenBuffers(1,&vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size()*sizeof(float), mesh.vertices.data(), GL_STATIC_DRAW);
    glGenBuffers(1,&ibo); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size()*sizeof(unsigned int), mesh.indices.data(), GL_STATIC_DRAW);

    // load texture
    Material& mat = materials.begin()->second;
    int w,h,comp;
    unsigned char* data = stbi_load((std::string("assets/")+mat.texPath).c_str(), &w,&h,&comp,4);
    glGenTextures(1,&tex); glBindTexture(GL_TEXTURE_2D,tex);
    glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w,h,0,GL_RGBA,GL_UNSIGNED_BYTE,data);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    stbi_image_free(data);

    return true;
}

void render(){
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glUseProgram(program);
    glBindBuffer(GL_ARRAY_BUFFER,vbo);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)0);
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1,2,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(3*sizeof(float)));
    glUniform1f(glGetUniformLocation(program,"rotX"),rotX);
    glUniform1f(glGetUniformLocation(program,"rotY"),rotY);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,ibo);
    glBindTexture(GL_TEXTURE_2D,tex);
    glDrawElements(GL_TRIANGLES, mesh.indices.size(), GL_UNSIGNED_INT,0);
    SDL_GL_SwapWindow(window);
}

void loop(){
    SDL_Event e;
    while(SDL_PollEvent(&e)){
        if (e.type==SDL_QUIT) emscripten_cancel_main_loop();
        else if(e.type==SDL_MOUSEBUTTONDOWN && e.button.button==SDL_BUTTON_LEFT){
            mouseDown=true; lastX=e.button.x; lastY=e.button.y;
        } else if(e.type==SDL_MOUSEBUTTONUP && e.button.button==SDL_BUTTON_LEFT){
            mouseDown=false;
        } else if(e.type==SDL_MOUSEMOTION && mouseDown){
            rotY += (e.motion.x - lastX)*0.01f;
            rotX += (e.motion.y - lastY)*0.01f;
            lastX = e.motion.x; lastY = e.motion.y;
        }
    }
    render();
}

int main(){
    init();
    emscripten_set_main_loop(loop, 0, 1);
    return 0;
}

